<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Samoura√Øs Meme Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Helvetica, Arial, sans-serif;
            background: #0a0a0a;
            color: #fff;
            min-height: 100vh;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            background: #111;
            border-bottom: 1px solid #222;
            padding: 0 20px;
        }

        .nav-tab {
            padding: 16px 24px;
            font-size: 14px;
            font-weight: 500;
            color: #888;
            text-decoration: none;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .nav-tab:hover {
            color: #fff;
        }

        .nav-tab.active {
            color: #ef4444;
            border-bottom-color: #ef4444;
        }

        .nav-tab .icon {
            margin-right: 8px;
        }

        .app {
            display: flex;
            height: calc(100vh - 53px);
        }

        /* Sidebar */
        .sidebar {
            width: 360px;
            background: #111;
            border-right: 1px solid #222;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .logo {
            font-size: 22px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo span {
            color: #ef4444;
        }

        .section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #666;
        }

        /* Format selector */
        .format-selector {
            display: flex;
            gap: 6px;
        }

        .format-btn {
            flex: 1;
            padding: 10px 6px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            color: #999;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .format-btn:hover {
            border-color: #444;
            color: #fff;
        }

        .format-btn.active {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            color: #fff;
        }

        .format-btn .ratio {
            font-size: 10px;
            color: #666;
        }

        .format-btn.active .ratio {
            color: #ef4444;
        }

        /* Import Tabs */
        .import-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .import-tab {
            flex: 1;
            padding: 10px 12px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            color: #888;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .import-tab:hover {
            border-color: #555;
            color: #fff;
        }

        .import-tab.active {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            color: #fff;
        }

        .import-tab-icon {
            font-size: 16px;
        }

        /* Upload zone */
        .upload-zone {
            border: 2px dashed #333;
            border-radius: 10px;
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-zone:hover {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.05);
        }

        .upload-zone.has-file {
            border-style: solid;
            border-color: #333;
            padding: 10px;
        }

        .upload-icon {
            font-size: 28px;
            margin-bottom: 6px;
        }

        .upload-text {
            font-size: 13px;
            color: #999;
        }

        .upload-text strong {
            color: #ef4444;
        }

        /* Google Drive Zone */
        .drive-zone {
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }

        .drive-browser {
            min-height: 120px;
        }

        .drive-connect {
            padding: 24px;
            text-align: center;
        }

        .drive-icon {
            margin-bottom: 12px;
        }

        .drive-connect-text {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 12px;
        }

        .btn-drive {
            padding: 10px 20px;
            background: #1a73e8;
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-drive:hover {
            background: #1557b0;
        }

        .drive-hint {
            font-size: 11px;
            color: #666;
            margin-top: 10px;
        }

        .drive-loading {
            padding: 32px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: #888;
            font-size: 13px;
        }

        .drive-files {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .drive-file {
            aspect-ratio: 1;
            background: #222;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .drive-file:hover {
            border-color: #ef4444;
            transform: scale(1.02);
        }

        .drive-file img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .drive-file-video::after {
            content: 'üé¨';
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
            padding: 2px 4px;
        }

        .drive-folder-select {
            padding: 10px 12px;
            background: #111;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .drive-folder-name {
            font-size: 12px;
            color: #888;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .drive-refresh-btn {
            padding: 4px 8px;
            background: #333;
            border: none;
            border-radius: 4px;
            color: #888;
            font-size: 11px;
            cursor: pointer;
        }

        .drive-refresh-btn:hover {
            background: #444;
            color: #fff;
        }

        .file-preview {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-preview img {
            width: 56px;
            height: 56px;
            object-fit: cover;
            border-radius: 6px;
        }

        .file-info {
            flex: 1;
            text-align: left;
        }

        .file-name {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 160px;
        }

        .file-size {
            font-size: 11px;
            color: #666;
        }

        .remove-file {
            padding: 6px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 16px;
        }

        .remove-file:hover {
            color: #ef4444;
        }

        /* Video loading spinner */
        .video-loading {
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #222;
            border-radius: 6px;
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid #333;
            border-top-color: #ef4444;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Text input */
        .text-input {
            width: 100%;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 14px;
            color: #fff;
            font-size: 15px;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
            transition: border-color 0.2s;
        }

        .text-input:focus {
            outline: none;
            border-color: #ef4444;
        }

        .text-input::placeholder {
            color: #666;
        }

        /* Slider */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ef4444;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .slider-value {
            font-size: 13px;
            color: #999;
            min-width: 45px;
            text-align: right;
        }

        /* Checkbox toggle */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #1a1a1a;
            border-radius: 8px;
            cursor: pointer;
        }

        .toggle-row span {
            font-size: 13px;
        }

        .toggle-switch {
            width: 40px;
            height: 22px;
            background: #333;
            border-radius: 11px;
            position: relative;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background: #ef4444;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }

        .toggle-switch.active::after {
            transform: translateX(18px);
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: #ef4444;
            color: #fff;
        }

        .btn-primary:hover {
            background: #dc2626;
        }

        .btn-primary:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #1a1a1a;
            color: #fff;
            border: 2px solid #333;
        }

        .btn-secondary:hover {
            border-color: #ef4444;
        }

        .btn-schedule {
            background: #1a1a1a;
            color: #f59e0b;
            border: 2px solid #f59e0b;
        }

        .btn-schedule:hover {
            background: rgba(245, 158, 11, 0.1);
        }

        .btn-schedule:disabled {
            background: #1a1a1a;
            color: #666;
            border-color: #333;
            cursor: not-allowed;
        }

        .spacer {
            flex: 1;
        }

        /* Preview area */
        .preview-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
            background: #0a0a0a;
            position: relative;
        }

        .canvas-container {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: visible !important; /* Allow controls to show outside */
            border: 1px solid #333;
        }

        /* Fabric.js creates its own wrapper div with class canvas-container - override it */
        .preview-area .canvas-container {
            overflow: visible !important;
        }
        
        .preview-area canvas {
            display: block;
        }

        .help-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        /* Hidden file input */
        #file-input {
            display: none;
        }

        /* Image controls hint */
        .image-hint {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 12px;
            font-size: 12px;
            color: #888;
            line-height: 1.5;
        }

        .image-hint strong {
            color: #ef4444;
        }

        /* Video Timeline */
        .timeline-container {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .timeline-header span {
            font-size: 12px;
            color: #888;
        }

        .timeline-duration {
            font-size: 11px;
            color: #ef4444;
            font-family: monospace;
        }

        .timeline-wrapper {
            position: relative;
            height: 50px;
            background: #111;
            border-radius: 6px;
            overflow: hidden;
        }

        .timeline-thumbnails {
            display: flex;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
        }

        .timeline-thumbnails canvas {
            height: 100%;
            flex-shrink: 0;
        }

        .timeline-selection {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(239, 68, 68, 0.2);
            border-left: 3px solid #ef4444;
            border-right: 3px solid #ef4444;
            cursor: move;
        }

        .timeline-handle {
            position: absolute;
            top: 0;
            width: 20px;
            height: 100%;
            background: #ef4444;
            cursor: ew-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .timeline-handle::after {
            content: '';
            width: 4px;
            height: 20px;
            background: rgba(255,255,255,0.9);
            border-radius: 2px;
        }

        .timeline-handle.start {
            left: 0;
            border-radius: 4px 0 0 4px;
        }

        .timeline-handle.end {
            right: 0;
            border-radius: 0 4px 4px 0;
        }

        .timeline-playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: #fff;
            pointer-events: none;
            z-index: 5;
        }

        .timeline-times {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 10px;
            color: #666;
            font-family: monospace;
        }

        .video-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .video-controls button {
            flex: 1;
            padding: 8px;
            background: #333;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .video-controls button:hover {
            background: #444;
        }

        .video-controls button.active {
            background: #ef4444;
        }

        /* Hidden video element */
        #video-source {
            display: none;
        }

        /* Media type indicator */
        .media-type-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 8px;
        }

        .media-type-badge.image {
            background: #22c55e;
            color: #fff;
        }

        .media-type-badge.video {
            background: #ef4444;
            color: #fff;
        }

        /* Responsive */
        @media (max-width: 900px) {
            .app {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 50vh;
                border-right: none;
                border-bottom: 1px solid #222;
            }
            .preview-area {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="nav-tabs">
        <a href="index.html" class="nav-tab active">
            <span class="icon">üé®</span>Cr√©er
        </a>
        <a href="calendar.html" class="nav-tab">
            <span class="icon">üìÖ</span>Calendrier
        </a>
        <a href="analytics.html" class="nav-tab">
            <span class="icon">üìä</span>Analytics
        </a>
    </nav>

    <div class="app">
        <div class="sidebar">
            <div class="logo">
                <span>‚öîÔ∏è</span> Samoura√Øs Studio
            </div>

            <!-- Format Selection -->
            <div class="section">
                <div class="section-title">Format</div>
                <div class="format-selector">
                    <button class="format-btn active" data-format="square" data-width="1080" data-height="1080">
                        Feed
                        <span class="ratio">1:1</span>
                    </button>
                    <button class="format-btn" data-format="portrait" data-width="1080" data-height="1350">
                        Portrait
                        <span class="ratio">4:5</span>
                    </button>
                    <button class="format-btn" data-format="story" data-width="1080" data-height="1920">
                        Reel
                        <span class="ratio">9:16</span>
                    </button>
                </div>
            </div>

            <!-- Media Upload (Image or Video) -->
            <div class="section">
                <div class="section-title">
                    M√©dia
                    <span class="media-type-badge image" id="media-type-badge" style="display: none;">Image</span>
                </div>
                
                <!-- Import Source Tabs -->
                <div class="import-tabs">
                    <button class="import-tab active" data-source="local">
                        <span class="import-tab-icon">üíª</span>
                        <span>Ordi</span>
                    </button>
                    <button class="import-tab" data-source="drive">
                        <span class="import-tab-icon">‚òÅÔ∏è</span>
                        <span>Drive</span>
                    </button>
                </div>
                
                <!-- Local Upload Zone -->
                <div class="upload-zone" id="upload-zone">
                    <div class="upload-icon">üñºÔ∏è</div>
                    <div class="upload-text"><strong>Clique</strong> ou glisse une image/vid√©o</div>
                </div>
                
                <!-- Google Drive Zone (hidden by default) -->
                <div class="drive-zone" id="drive-zone" style="display: none;">
                    <div class="drive-browser" id="drive-browser">
                        <div class="drive-loading" id="drive-loading" style="display: none;">
                            <div class="loading-spinner"></div>
                            <span>Connexion √† Google Drive...</span>
                        </div>
                        <div class="drive-connect" id="drive-connect">
                            <div class="drive-icon">
                                <svg width="40" height="40" viewBox="0 0 87.3 78" xmlns="http://www.w3.org/2000/svg">
                                    <path d="m6.6 66.85 3.85 6.65c.8 1.4 1.95 2.5 3.3 3.3l13.75-23.8h-27.5c0 1.55.4 3.1 1.2 4.5z" fill="#0066da"/>
                                    <path d="m43.65 25-13.75-23.8c-1.35.8-2.5 1.9-3.3 3.3l-25.4 44a9.06 9.06 0 0 0 -1.2 4.5h27.5z" fill="#00ac47"/>
                                    <path d="m73.55 76.8c1.35-.8 2.5-1.9 3.3-3.3l1.6-2.75 7.65-13.25c.8-1.4 1.2-2.95 1.2-4.5h-27.502l5.852 11.5z" fill="#ea4335"/>
                                    <path d="m43.65 25 13.75-23.8c-1.35-.8-2.9-1.2-4.5-1.2h-18.5c-1.6 0-3.15.45-4.5 1.2z" fill="#00832d"/>
                                    <path d="m59.8 53h-32.3l-13.75 23.8c1.35.8 2.9 1.2 4.5 1.2h50.8c1.6 0 3.15-.45 4.5-1.2z" fill="#2684fc"/>
                                    <path d="m73.4 26.5-12.7-22c-.8-1.4-1.95-2.5-3.3-3.3l-13.75 23.8 16.15 28h27.45c0-1.55-.4-3.1-1.2-4.5z" fill="#ffba00"/>
                                </svg>
                            </div>
                            <div class="drive-connect-text">Connecte-toi √† Google Drive</div>
                            <button class="btn btn-drive" id="connect-drive-btn">
                                ‚òÅÔ∏è Ouvrir Google Drive
                            </button>
                            <div class="drive-hint">S√©lectionne des images ou vid√©os depuis ton Drive</div>
                        </div>
                        <div class="drive-files" id="drive-files" style="display: none;">
                            <!-- Files will be loaded here -->
                        </div>
                    </div>
                </div>
                
                <input type="file" id="file-input" accept="image/*,video/*">
                <div class="image-hint">
                    <strong>Astuce :</strong> Clique sur le m√©dia dans le canvas pour le d√©placer et le redimensionner. La frame reste fixe.
                </div>
                <button class="btn btn-secondary" id="select-image-btn" style="display: none; margin-top: 8px;">üéØ S√©lectionner le m√©dia</button>
                
                <!-- Video Timeline (hidden by default) -->
                <div class="timeline-container" id="timeline-container" style="display: none;">
                    <div class="timeline-header">
                        <span>‚úÇÔ∏è Trim vid√©o</span>
                        <span class="timeline-duration" id="trim-duration">0:00</span>
                    </div>
                    <div class="timeline-wrapper" id="timeline-wrapper">
                        <div class="timeline-thumbnails" id="timeline-thumbnails"></div>
                        <div class="timeline-selection" id="timeline-selection">
                            <div class="timeline-handle start" id="handle-start"></div>
                            <div class="timeline-handle end" id="handle-end"></div>
                        </div>
                        <div class="timeline-playhead" id="timeline-playhead"></div>
                    </div>
                    <div class="timeline-times">
                        <span id="time-start">0:00</span>
                        <span id="time-end">0:00</span>
                    </div>
                    <div class="video-controls">
                        <button id="btn-play">‚ñ∂Ô∏è Play</button>
                        <button id="btn-preview">üëÅÔ∏è Preview</button>
                    </div>
                </div>
                
                <!-- Hidden video element for processing -->
                <video id="video-source" muted playsinline></video>
            </div>

            <!-- Top Text -->
            <div class="section">
                <div class="section-title">Texte du meme</div>
                <textarea class="text-input" id="meme-text" placeholder="Quand tu r√©alises que..."></textarea>
            </div>

            <!-- Text Size -->
            <div class="section">
                <div class="section-title">Taille du texte</div>
                <div class="slider-container">
                    <input type="range" class="slider" id="text-size" min="24" max="72" value="42">
                    <span class="slider-value" id="text-size-value">42px</span>
                </div>
            </div>

            <!-- Image Scale -->
            <div class="section" id="image-scale-section" style="display: none;">
                <div class="section-title">Zoom image</div>
                <div class="slider-container">
                    <input type="range" class="slider" id="image-scale" min="50" max="200" value="100">
                    <span class="slider-value" id="image-scale-value">100%</span>
                </div>
            </div>

            <!-- Overlay Text Toggle -->
            <div class="section">
                <div class="toggle-row" id="overlay-toggle">
                    <span>Texte sur l'image</span>
                    <div class="toggle-switch" id="overlay-switch"></div>
                </div>
                <input type="text" class="text-input" id="overlay-text" placeholder="Texte overlay..." style="display: none; min-height: auto; padding: 12px;">
            </div>

            <!-- Watermark Opacity -->
            <div class="section">
                <div class="section-title">Opacit√© du logo</div>
                <div class="slider-container">
                    <input type="range" class="slider" id="watermark-opacity" min="0" max="100" value="100">
                    <span class="slider-value" id="watermark-opacity-value">100%</span>
                </div>
            </div>

            <div class="spacer"></div>

            <!-- Actions -->
            <button class="btn btn-secondary" id="reset-btn">üîÑ R√©initialiser</button>
            <button class="btn btn-primary" id="export-btn" disabled>üì• T√©l√©charger le meme</button>
            <button class="btn btn-schedule" id="schedule-btn" disabled>üìÖ Planifier</button>
        </div>

        <div class="preview-area">
            <div class="canvas-container">
                <canvas id="meme-canvas"></canvas>
            </div>
            <div class="help-text">
                Frame fixe ‚Ä¢ Glisse l'image pour la repositionner ‚Ä¢ Zoom avec le slider ou les poign√©es
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // TEMPLATES DEFINITION
        // ============================================
        const TEMPLATES = {
            square: {
                width: 1080,
                height: 1080,
                frame: {
                    x: 54,          // 5% padding
                    y: 195,         // ~18% from top
                    width: 972,     // 90% width
                    height: 810,    // 75% height
                    radius: 27      // 2.5% corner radius
                },
                textArea: {
                    x: 54,
                    y: 40,
                    width: 972,
                    maxY: 180       // Don't go below this
                },
                watermark: {
                    x: 1010,
                    y: 1040
                }
            },
            portrait: {
                width: 1080,
                height: 1350,
                frame: {
                    x: 54,
                    y: 220,
                    width: 972,
                    height: 1020,
                    radius: 27
                },
                textArea: {
                    x: 54,
                    y: 40,
                    width: 972,
                    maxY: 200
                },
                watermark: {
                    x: 1010,
                    y: 1300
                }
            },
            story: {
                width: 1080,
                height: 1920,
                frame: {
                    x: 54,
                    y: 350,
                    width: 972,
                    height: 1300,
                    radius: 27
                },
                textArea: {
                    x: 54,
                    y: 280,
                    width: 972,
                    maxY: 330
                },
                watermark: {
                    x: 1010,
                    y: 1700
                }
            }
        };

        // ============================================
        // STATE
        // ============================================
        const state = {
            currentTemplate: 'square',
            // Media state (image or video)
            mediaType: null, // 'image' or 'video'
            imageSrc: null,
            imageName: '',
            imageSize: 0,
            imageScale: 100,
            imageOffsetX: 0,
            imageOffsetY: 0,
            // Video-specific state
            videoFile: null,
            videoDuration: 0,
            trimStart: 0,
            trimEnd: 0,
            isPlaying: false,
            // Text state
            text: '',
            textSize: 42,
            overlayText: '',
            showOverlay: false,
            // Watermark state
            watermarkOpacity: 100,
            // Canvas state
            scale: 1
        };

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const uploadZone = document.getElementById('upload-zone');
        const fileInput = document.getElementById('file-input');
        const memeTextInput = document.getElementById('meme-text');
        const textSizeSlider = document.getElementById('text-size');
        const textSizeValue = document.getElementById('text-size-value');
        const imageScaleSection = document.getElementById('image-scale-section');
        const imageScaleSlider = document.getElementById('image-scale');
        const imageScaleValue = document.getElementById('image-scale-value');
        const selectImageBtn = document.getElementById('select-image-btn');
        const overlayToggle = document.getElementById('overlay-toggle');
        const overlaySwitch = document.getElementById('overlay-switch');
        const overlayTextInput = document.getElementById('overlay-text');
        const resetBtn = document.getElementById('reset-btn');
        const exportBtn = document.getElementById('export-btn');
        const scheduleBtn = document.getElementById('schedule-btn');
        const formatBtns = document.querySelectorAll('.format-btn');
        
        // Import source elements
        const importTabs = document.querySelectorAll('.import-tab');
        const driveZone = document.getElementById('drive-zone');
        const driveConnect = document.getElementById('drive-connect');
        const driveLoading = document.getElementById('drive-loading');
        const driveFiles = document.getElementById('drive-files');
        const connectDriveBtn = document.getElementById('connect-drive-btn');
        
        // Watermark opacity
        const watermarkOpacitySlider = document.getElementById('watermark-opacity');
        const watermarkOpacityValue = document.getElementById('watermark-opacity-value');
        
        // Video-related elements
        const mediaTypeBadge = document.getElementById('media-type-badge');
        const timelineContainer = document.getElementById('timeline-container');
        const timelineWrapper = document.getElementById('timeline-wrapper');
        const timelineThumbnails = document.getElementById('timeline-thumbnails');
        const timelineSelection = document.getElementById('timeline-selection');
        const handleStart = document.getElementById('handle-start');
        const handleEnd = document.getElementById('handle-end');
        const timelinePlayhead = document.getElementById('timeline-playhead');
        const timeStartEl = document.getElementById('time-start');
        const timeEndEl = document.getElementById('time-end');
        const trimDurationEl = document.getElementById('trim-duration');
        const btnPlay = document.getElementById('btn-play');
        const btnPreview = document.getElementById('btn-preview');
        const videoSource = document.getElementById('video-source');

        // ============================================
        // FABRIC CANVAS
        // ============================================
        let canvas;
        let textBox, imageObj, overlayTextObj, frameRect, frameBorder, watermark, templateBg;
        let clipRect; // The fixed clipping rectangle

        // Canvas padding to show controls outside template - needs to be large enough for scaled images
        const CANVAS_PADDING = 350;

        function initCanvas() {
            canvas = new fabric.Canvas('meme-canvas', {
                backgroundColor: '#2a2a2a', // Lighter dark background to distinguish from page
                selection: true,
                preserveObjectStacking: true,
                perPixelTargetFind: false // Click on bounding box, not just visible pixels
            });

            // Custom controls style - larger and more visible
            fabric.Object.prototype.set({
                borderColor: '#ef4444',
                cornerColor: '#ef4444',
                cornerStrokeColor: '#ffffff',
                cornerSize: 16,
                cornerStyle: 'circle',
                transparentCorners: false,
                borderScaleFactor: 2,
                borderDashArray: [5, 5],
                padding: 10
            });

            updateCanvasSize();
            createElements();
            setupCanvasHoverEffects();
            setupSnapping();
        }

        function setupCanvasHoverEffects() {
            // Show border on hover
            canvas.on('mouse:over', function(e) {
                if (e.target && e.target.selectable) {
                    e.target._showBorder = true;
                    e.target.set('dirty', true);
                    canvas.renderAll();
                }
            });

            canvas.on('mouse:out', function(e) {
                if (e.target && e.target._showBorder) {
                    e.target._showBorder = false;
                    e.target.set('dirty', true);
                    canvas.renderAll();
                }
            });
        }

        // ============================================
        // SNAPPING / MAGNET SYSTEM
        // ============================================
        const SNAP_THRESHOLD = 15; // Distance in pixels to trigger snap
        let snapLines = []; // Visual guide lines

        function setupSnapping() {
            canvas.on('object:moving', function(e) {
                const obj = e.target;
                if (!obj) return;

                const template = TEMPLATES[state.currentTemplate];
                const frame = template.frame;
                const offset = CANVAS_PADDING;
                const textArea = template.textArea;

                // Define snap points (left edges, centers, right edges)
                const snapPointsX = [
                    offset + textArea.x,                           // Text area left
                    offset + frame.x,                              // Frame left
                    offset + template.width / 2,                   // Template center
                    offset + frame.x + frame.width / 2,            // Frame center
                    offset + frame.x + frame.width,                // Frame right
                    offset + template.width - textArea.x,          // Text area right (mirrored)
                ];

                const snapPointsY = [
                    offset + textArea.y,                           // Text area top
                    offset + frame.y,                              // Frame top
                    offset + template.height / 2,                  // Template center
                    offset + frame.y + frame.height,               // Frame bottom
                ];

                // Get object bounds
                const objLeft = obj.left;
                const objTop = obj.top;
                const objRight = obj.left + (obj.width * (obj.scaleX || 1));
                const objCenterX = obj.left + (obj.width * (obj.scaleX || 1)) / 2;
                const objCenterY = obj.top + (obj.height * (obj.scaleY || 1)) / 2;

                let snappedX = false;
                let snappedY = false;
                
                // Clear previous snap lines
                clearSnapLines();

                // Check X snapping (left edge)
                for (const snapX of snapPointsX) {
                    if (Math.abs(objLeft - snapX) < SNAP_THRESHOLD) {
                        obj.set('left', snapX);
                        snappedX = true;
                        showSnapLine('vertical', snapX);
                        break;
                    }
                }

                // Check X snapping (center) - only for text objects
                if (!snappedX && (obj === textBox || obj === overlayTextObj)) {
                    const templateCenterX = offset + template.width / 2;
                    if (Math.abs(objCenterX - templateCenterX) < SNAP_THRESHOLD) {
                        obj.set('left', templateCenterX - (obj.width * (obj.scaleX || 1)) / 2);
                        snappedX = true;
                        showSnapLine('vertical', templateCenterX);
                    }
                }

                // Check Y snapping (top edge)
                for (const snapY of snapPointsY) {
                    if (Math.abs(objTop - snapY) < SNAP_THRESHOLD) {
                        obj.set('top', snapY);
                        snappedY = true;
                        showSnapLine('horizontal', snapY);
                        break;
                    }
                }

                canvas.renderAll();
            });

            canvas.on('object:modified', function() {
                clearSnapLines();
                canvas.renderAll();
            });

            canvas.on('mouse:up', function() {
                clearSnapLines();
                canvas.renderAll();
            });
        }

        function showSnapLine(orientation, position) {
            const template = TEMPLATES[state.currentTemplate];
            const offset = CANVAS_PADDING;
            
            let line;
            if (orientation === 'vertical') {
                line = new fabric.Line([position, offset, position, offset + template.height], {
                    stroke: '#ef4444',
                    strokeWidth: 1,
                    strokeDashArray: [5, 3],
                    selectable: false,
                    evented: false,
                    opacity: 0.8
                });
            } else {
                line = new fabric.Line([offset, position, offset + template.width, position], {
                    stroke: '#ef4444',
                    strokeWidth: 1,
                    strokeDashArray: [5, 3],
                    selectable: false,
                    evented: false,
                    opacity: 0.8
                });
            }
            
            canvas.add(line);
            snapLines.push(line);
        }

        function clearSnapLines() {
            snapLines.forEach(line => canvas.remove(line));
            snapLines = [];
        }

        function updateCanvasSize() {
            const template = TEMPLATES[state.currentTemplate];
            const { width, height } = template;
            const container = document.querySelector('.preview-area');
            const maxW = container.clientWidth - 60;
            const maxH = container.clientHeight - 100;
            
            // Calculate scale based on template + padding
            const totalWidth = width + (CANVAS_PADDING * 2);
            const totalHeight = height + (CANVAS_PADDING * 2);
            
            state.scale = Math.min(maxW / totalWidth, maxH / totalHeight, 0.4);
            
            canvas.setWidth(totalWidth * state.scale);
            canvas.setHeight(totalHeight * state.scale);
            canvas.setZoom(state.scale);
        }

        function createElements() {
            canvas.clear();
            canvas.backgroundColor = '#2a2a2a'; // Lighter dark area outside template

            const template = TEMPLATES[state.currentTemplate];
            const frame = template.frame;
            const offset = CANVAS_PADDING; // Offset for all elements

            // White template background
            templateBg = new fabric.Rect({
                left: offset,
                top: offset,
                width: template.width,
                height: template.height,
                fill: '#ffffff',
                selectable: false,
                evented: false
            });
            canvas.add(templateBg);

            // Create the clip path (absolute position - stays fixed)
            clipRect = new fabric.Rect({
                left: frame.x + offset,
                top: frame.y + offset,
                width: frame.width,
                height: frame.height,
                rx: frame.radius,
                ry: frame.radius,
                absolutePositioned: true
            });

            // Frame placeholder (gray background when no image)
            frameRect = new fabric.Rect({
                left: frame.x + offset,
                top: frame.y + offset,
                width: frame.width,
                height: frame.height,
                rx: frame.radius,
                ry: frame.radius,
                fill: '#f0f0f0',
                selectable: false,
                evented: false
            });
            canvas.add(frameRect);

            // Frame border - interactive indicator (shows where image area is)
            frameBorder = new fabric.Rect({
                left: frame.x + offset,
                top: frame.y + offset,
                width: frame.width,
                height: frame.height,
                rx: frame.radius,
                ry: frame.radius,
                fill: 'transparent',
                stroke: '#ddd',
                strokeWidth: 2,
                strokeDashArray: [8, 4],
                selectable: false,
                evented: false
            });
            canvas.add(frameBorder);

            // Text box
            const textArea = template.textArea;
            textBox = new fabric.Textbox(state.text || 'Tape ton texte...', {
                left: textArea.x + offset,
                top: textArea.y + offset,
                width: textArea.width,
                fontSize: state.textSize,
                fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',
                fontWeight: '300',
                fill: '#000000',
                lineHeight: 1.2,
                textAlign: 'left',
                splitByGrapheme: false,
                hasControls: true,
                cornerSize: 16,
                hoverCursor: 'move',
                moveCursor: 'move'
            });
            canvas.add(textBox);

            // Watermark (logo or text fallback)
            const wm = template.watermark;
            if (logoImage) {
                // Use logo image
                watermark = new fabric.Image(logoImage.getElement(), {
                    left: wm.x + offset,
                    top: wm.y + offset,
                    originX: 'right',
                    originY: 'bottom',
                    scaleX: 0.15,
                    scaleY: 0.15,
                    opacity: state.watermarkOpacity / 100,
                    selectable: true,
                    hasControls: true,
                    cornerSize: 16,
                    hoverCursor: 'move',
                    moveCursor: 'move'
                });
            } else {
                // Fallback to text if logo not loaded yet
                watermark = new fabric.Text('SAMOURA√èS', {
                    left: wm.x + offset,
                    top: wm.y + offset,
                    fontSize: template.width * 0.04,
                    fontFamily: 'Impact, sans-serif',
                    fontWeight: '800',
                    fill: '#ffffff',
                    stroke: '#333333',
                    strokeWidth: 2,
                    angle: -3,
                    originX: 'right',
                    originY: 'bottom',
                    opacity: state.watermarkOpacity / 100,
                    shadow: new fabric.Shadow({
                        color: 'rgba(0,0,0,0.3)',
                        blur: 4,
                        offsetX: 2,
                        offsetY: 2
                    }),
                    selectable: true,
                    hasControls: true,
                    cornerSize: 16,
                    hoverCursor: 'move',
                    moveCursor: 'move'
                });
            }
            canvas.add(watermark);

            canvas.renderAll();
        }

        // ============================================
        // MEDIA HANDLING (IMAGE + VIDEO)
        // ============================================
        function loadMedia(file) {
            const isVideo = file.type.startsWith('video/');
            state.mediaType = isVideo ? 'video' : 'image';
            
            // Update badge
            mediaTypeBadge.style.display = 'inline-block';
            mediaTypeBadge.textContent = isVideo ? 'Vid√©o' : 'Image';
            mediaTypeBadge.className = `media-type-badge ${isVideo ? 'video' : 'image'}`;
            
            if (isVideo) {
                loadVideo(file);
            } else {
                loadImage(file);
            }
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                state.imageSrc = e.target.result;
                state.imageName = file.name;
                state.imageSize = file.size;
                state.imageScale = 100;
                state.imageOffsetX = 0;
                state.imageOffsetY = 0;
                
                // Hide video timeline
                timelineContainer.style.display = 'none';
                
                updateUploadZone();
                addImageToCanvas(e.target.result);
                
                imageScaleSection.style.display = 'block';
                imageScaleSlider.value = 100;
                imageScaleValue.textContent = '100%';
                selectImageBtn.style.display = 'block';
                
                exportBtn.disabled = false;
                exportBtn.textContent = 'üì• T√©l√©charger le meme';
                scheduleBtn.disabled = false;
            };
            reader.readAsDataURL(file);
        }

        function loadVideo(file) {
            state.videoFile = file;
            state.imageName = file.name;
            state.imageSize = file.size;
            state.imageScale = 100;
            state.imageOffsetX = 0;
            state.imageOffsetY = 0;
            
            // Show loading state
            uploadZone.classList.add('has-file');
            uploadZone.innerHTML = `
                <div class="file-preview">
                    <div class="video-loading">
                        <div class="loading-spinner"></div>
                    </div>
                    <div class="file-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">Chargement de la vid√©o...</div>
                    </div>
                </div>
            `;
            
            const url = URL.createObjectURL(file);
            videoSource.src = url;
            
            videoSource.onloadedmetadata = () => {
                state.videoDuration = videoSource.duration;
                state.trimStart = 0;
                state.trimEnd = Math.min(videoSource.duration, 30); // Max 30s default
                
                updateUploadZone();
                generateThumbnails();
                updateTimelineUI();
                
                // Show video timeline
                timelineContainer.style.display = 'block';
                imageScaleSection.style.display = 'block';
                imageScaleSlider.value = 100;
                imageScaleValue.textContent = '100%';
                selectImageBtn.style.display = 'block';
                
                // Capture first frame for canvas preview
                captureVideoFrame(0);
                
                exportBtn.disabled = false;
                exportBtn.textContent = 'üé¨ Exporter la vid√©o';
                scheduleBtn.disabled = false;
            };
            
            videoSource.load();
        }

        function captureVideoFrame(time) {
            return new Promise((resolve) => {
                videoSource.currentTime = time;
                videoSource.onseeked = () => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = videoSource.videoWidth;
                    tempCanvas.height = videoSource.videoHeight;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(videoSource, 0, 0);
                    
                    const dataURL = tempCanvas.toDataURL('image/jpeg', 0.8);
                    state.imageSrc = dataURL;
                    
                    addImageToCanvas(dataURL);
                    resolve(dataURL);
                };
            });
        }

        async function generateThumbnails() {
            const numThumbnails = 10;
            const duration = state.videoDuration;
            const interval = duration / numThumbnails;
            
            timelineThumbnails.innerHTML = '';
            
            const thumbWidth = timelineWrapper.clientWidth / numThumbnails;
            const thumbHeight = 50;
            
            for (let i = 0; i < numThumbnails; i++) {
                const time = i * interval;
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = thumbWidth;
                thumbCanvas.height = thumbHeight;
                thumbCanvas.style.width = thumbWidth + 'px';
                
                timelineThumbnails.appendChild(thumbCanvas);
                
                // Capture thumbnail asynchronously
                await captureThumbnail(time, thumbCanvas);
            }
        }

        function captureThumbnail(time, thumbCanvas) {
            return new Promise((resolve) => {
                videoSource.currentTime = time;
                videoSource.onseeked = () => {
                    const ctx = thumbCanvas.getContext('2d');
                    const aspectRatio = videoSource.videoWidth / videoSource.videoHeight;
                    const drawHeight = thumbCanvas.height;
                    const drawWidth = drawHeight * aspectRatio;
                    const offsetX = (thumbCanvas.width - drawWidth) / 2;
                    
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, thumbCanvas.width, thumbCanvas.height);
                    ctx.drawImage(videoSource, offsetX, 0, drawWidth, drawHeight);
                    resolve();
                };
            });
        }

        // ============================================
        // TIMELINE CONTROLS
        // ============================================
        function updateTimelineUI() {
            const duration = state.videoDuration;
            const startPercent = (state.trimStart / duration) * 100;
            const endPercent = (state.trimEnd / duration) * 100;
            
            timelineSelection.style.left = startPercent + '%';
            timelineSelection.style.width = (endPercent - startPercent) + '%';
            
            timeStartEl.textContent = formatTime(state.trimStart);
            timeEndEl.textContent = formatTime(state.trimEnd);
            trimDurationEl.textContent = formatTime(state.trimEnd - state.trimStart);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function setupTimelineInteraction() {
            let dragging = null;
            let startX = 0;
            let startValue = 0;
            let lastPreviewTime = 0;
            const PREVIEW_THROTTLE = 100; // ms between preview updates
            
            const getTimeFromX = (x) => {
                const rect = timelineWrapper.getBoundingClientRect();
                const percent = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
                return percent * state.videoDuration;
            };
            
            // Throttled preview update
            const updatePreview = (time) => {
                const now = Date.now();
                if (now - lastPreviewTime > PREVIEW_THROTTLE) {
                    lastPreviewTime = now;
                    captureVideoFrame(time);
                }
            };
            
            handleStart.addEventListener('mousedown', (e) => {
                dragging = 'start';
                startX = e.clientX;
                startValue = state.trimStart;
                e.preventDefault();
            });
            
            handleEnd.addEventListener('mousedown', (e) => {
                dragging = 'end';
                startX = e.clientX;
                startValue = state.trimEnd;
                e.preventDefault();
            });
            
            // Also allow dragging the selection area
            timelineSelection.addEventListener('mousedown', (e) => {
                if (e.target === timelineSelection) {
                    dragging = 'selection';
                    startX = e.clientX;
                    startValue = state.trimStart;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                
                const time = getTimeFromX(e.clientX);
                const duration = state.videoDuration;
                const trimLength = state.trimEnd - state.trimStart;
                
                if (dragging === 'start') {
                    state.trimStart = Math.max(0, Math.min(time, state.trimEnd - 0.5));
                    // Live preview: show first frame of trimmed section
                    updatePreview(state.trimStart);
                } else if (dragging === 'end') {
                    state.trimEnd = Math.min(duration, Math.max(time, state.trimStart + 0.5));
                    // Live preview: show last frame of trimmed section
                    updatePreview(state.trimEnd);
                } else if (dragging === 'selection') {
                    const delta = time - getTimeFromX(startX);
                    let newStart = startValue + delta;
                    let newEnd = newStart + trimLength;
                    
                    if (newStart < 0) {
                        newStart = 0;
                        newEnd = trimLength;
                    }
                    if (newEnd > duration) {
                        newEnd = duration;
                        newStart = duration - trimLength;
                    }
                    
                    state.trimStart = newStart;
                    state.trimEnd = newEnd;
                }
                
                updateTimelineUI();
            });
            
            document.addEventListener('mouseup', async () => {
                if (dragging) {
                    const wasDragging = dragging;
                    dragging = null;
                    // Final preview: show the appropriate frame based on what was dragged
                    if (wasDragging === 'start') {
                        await captureVideoFrame(state.trimStart);
                    } else if (wasDragging === 'end') {
                        await captureVideoFrame(state.trimEnd);
                    } else {
                        await captureVideoFrame(state.trimStart);
                    }
                }
            });
            
            // Click on timeline to seek
            timelineWrapper.addEventListener('click', async (e) => {
                if (e.target === handleStart || e.target === handleEnd) return;
                
                const time = getTimeFromX(e.clientX);
                videoSource.currentTime = time;
                updatePlayhead(time);
                await captureVideoFrame(time);
            });
            
            // Play button
            btnPlay.addEventListener('click', () => {
                if (state.isPlaying) {
                    pauseVideo();
                } else {
                    playVideo();
                }
            });
            
            // Preview button - play trimmed section
            btnPreview.addEventListener('click', () => {
                previewTrimmedSection();
            });
        }

        function updatePlayhead(time) {
            const percent = (time / state.videoDuration) * 100;
            timelinePlayhead.style.left = percent + '%';
        }

        function playVideo() {
            state.isPlaying = true;
            btnPlay.textContent = '‚è∏Ô∏è Pause';
            btnPlay.classList.add('active');
            
            videoSource.currentTime = state.trimStart;
            videoSource.play();
            
            const updateFrame = () => {
                if (!state.isPlaying) return;
                
                const currentTime = videoSource.currentTime;
                updatePlayhead(currentTime);
                
                // Update canvas preview
                if (imageObj) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = videoSource.videoWidth;
                    tempCanvas.height = videoSource.videoHeight;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(videoSource, 0, 0);
                    
                    imageObj.setSrc(tempCanvas.toDataURL('image/jpeg', 0.8), () => {
                        canvas.renderAll();
                    });
                }
                
                if (currentTime >= state.trimEnd) {
                    pauseVideo();
                    return;
                }
                
                requestAnimationFrame(updateFrame);
            };
            
            requestAnimationFrame(updateFrame);
        }

        function pauseVideo() {
            state.isPlaying = false;
            btnPlay.textContent = '‚ñ∂Ô∏è Play';
            btnPlay.classList.remove('active');
            videoSource.pause();
        }

        async function previewTrimmedSection() {
            await captureVideoFrame(state.trimStart);
            playVideo();
        }

        function addImageToCanvas(src) {
            fabric.Image.fromURL(src, (img) => {
                if (imageObj) {
                    canvas.remove(imageObj);
                }

                const template = TEMPLATES[state.currentTemplate];
                const frame = template.frame;
                const offset = CANVAS_PADDING;

                // Calculate scale to cover the frame
                const scaleX = frame.width / img.width;
                const scaleY = frame.height / img.height;
                const baseScale = Math.max(scaleX, scaleY);
                const finalScale = baseScale * (state.imageScale / 100);

                // Center the image in the frame (with offset)
                const centerX = frame.x + frame.width / 2 + offset;
                const centerY = frame.y + frame.height / 2 + offset;

                img.set({
                    left: centerX + state.imageOffsetX,
                    top: centerY + state.imageOffsetY,
                    originX: 'center',
                    originY: 'center',
                    scaleX: finalScale,
                    scaleY: finalScale,
                    hasControls: true,
                    hasBorders: true,
                    cornerSize: 18,
                    // Lock rotation, only allow scale and move
                    lockRotation: true,
                    // Apply the fixed clip path
                    clipPath: clipRect,
                    // Visual styling
                    strokeWidth: 0,
                    borderColor: '#ef4444',
                    borderDashArray: [5, 5],
                    hoverCursor: 'move',
                    moveCursor: 'move'
                });

                // Store base scale for slider calculations
                img._baseScale = baseScale;

                imageObj = img;
                canvas.add(imageObj);
                
                // Reorder layers - templateBg at very back, then frameRect, then image
                canvas.sendToBack(imageObj);
                canvas.sendToBack(frameBorder);
                canvas.sendToBack(frameRect);
                canvas.sendToBack(templateBg);
                canvas.bringToFront(textBox);
                canvas.bringToFront(watermark);
                
                if (overlayTextObj) {
                    canvas.bringToFront(overlayTextObj);
                }

                // Track image movement
                imageObj.on('moving', function() {
                    const template = TEMPLATES[state.currentTemplate];
                    const frame = template.frame;
                    const offset = CANVAS_PADDING;
                    const centerX = frame.x + frame.width / 2 + offset;
                    const centerY = frame.y + frame.height / 2 + offset;
                    
                    state.imageOffsetX = this.left - centerX;
                    state.imageOffsetY = this.top - centerY;
                });

                // Track image scaling
                imageObj.on('scaling', function() {
                    const currentScale = this.scaleX;
                    const baseScale = this._baseScale;
                    const percentage = Math.round((currentScale / baseScale) * 100);
                    
                    state.imageScale = percentage;
                    imageScaleSlider.value = Math.min(200, Math.max(50, percentage));
                    imageScaleValue.textContent = percentage + '%';
                });

                canvas.renderAll();
            }, { crossOrigin: 'anonymous' });
        }

        function updateImageScale(percentage) {
            state.imageScale = percentage;
            imageScaleValue.textContent = percentage + '%';
            
            if (imageObj && imageObj._baseScale) {
                const newScale = imageObj._baseScale * (percentage / 100);
                imageObj.set({
                    scaleX: newScale,
                    scaleY: newScale
                });
                canvas.renderAll();
            }
        }

        function updateUploadZone() {
            if (state.imageSrc || state.videoFile) {
                const sizeKB = Math.round(state.imageSize / 1024);
                const isVideo = state.mediaType === 'video';
                const icon = isVideo ? 'üé¨' : 'üñºÔ∏è';
                const previewSrc = state.imageSrc || ''; // For video, this is the first frame
                
                uploadZone.classList.add('has-file');
                uploadZone.innerHTML = `
                    <div class="file-preview">
                        ${previewSrc ? `<img src="${previewSrc}" alt="preview">` : `<div style="width:56px;height:56px;background:#333;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:24px;">${icon}</div>`}
                        <div class="file-info">
                            <div class="file-name">${state.imageName}</div>
                            <div class="file-size">${sizeKB > 1024 ? (sizeKB/1024).toFixed(1) + ' MB' : sizeKB + ' KB'}${isVideo ? ' ‚Ä¢ ' + formatTime(state.videoDuration) : ''}</div>
                        </div>
                        <button class="remove-file" onclick="removeImage(event)">‚úï</button>
                    </div>
                `;
            } else {
                uploadZone.classList.remove('has-file');
                uploadZone.innerHTML = `
                    <div class="upload-icon">üñºÔ∏è</div>
                    <div class="upload-text"><strong>Clique</strong> ou glisse une image/vid√©o</div>
                `;
            }
        }

        window.removeImage = function(e) {
            e.stopPropagation();
            
            // Reset all media state
            state.mediaType = null;
            state.imageSrc = null;
            state.imageName = '';
            state.imageSize = 0;
            state.imageScale = 100;
            state.imageOffsetX = 0;
            state.imageOffsetY = 0;
            
            // Reset video state
            state.videoFile = null;
            state.videoDuration = 0;
            state.trimStart = 0;
            state.trimEnd = 0;
            state.isPlaying = false;
            
            // Clean up video source
            if (videoSource.src) {
                URL.revokeObjectURL(videoSource.src);
                videoSource.src = '';
            }
            
            fileInput.value = '';
            
            if (imageObj) {
                canvas.remove(imageObj);
                imageObj = null;
            }
            
            // Hide all media-related UI
            imageScaleSection.style.display = 'none';
            selectImageBtn.style.display = 'none';
            timelineContainer.style.display = 'none';
            mediaTypeBadge.style.display = 'none';
            
            updateUploadZone();
            exportBtn.disabled = true;
            exportBtn.textContent = 'üì• T√©l√©charger le meme';
            scheduleBtn.disabled = true;
            canvas.renderAll();
        };

        // ============================================
        // TEXT HANDLING
        // ============================================
        function updateText(text) {
            state.text = text;
            if (textBox) {
                textBox.set({
                    text: text || 'Tape ton texte...',
                    fill: '#000000'
                });
                canvas.renderAll();
            }
        }

        function updateTextSize(size) {
            state.textSize = size;
            textSizeValue.textContent = size + 'px';
            if (textBox) {
                textBox.set({ fontSize: parseInt(size) });
                canvas.renderAll();
            }
        }

        // ============================================
        // OVERLAY TEXT
        // ============================================
        function toggleOverlay() {
            state.showOverlay = !state.showOverlay;
            overlaySwitch.classList.toggle('active', state.showOverlay);
            overlayTextInput.style.display = state.showOverlay ? 'block' : 'none';
            
            if (state.showOverlay && state.overlayText) {
                addOverlayText();
            } else if (overlayTextObj) {
                canvas.remove(overlayTextObj);
                overlayTextObj = null;
            }
            canvas.renderAll();
        }

        function addOverlayText() {
            if (overlayTextObj) {
                canvas.remove(overlayTextObj);
            }

            const template = TEMPLATES[state.currentTemplate];
            const frame = template.frame;
            const offset = CANVAS_PADDING;

            overlayTextObj = new fabric.Text(state.overlayText.toUpperCase(), {
                left: frame.x + frame.width / 2 + offset,
                top: frame.y + frame.height - 60 + offset,
                fontSize: template.width * 0.055,
                fontFamily: 'Impact, Haettenschweiler, sans-serif',
                fontWeight: '900',
                fill: '#ffffff',
                stroke: '#000000',
                strokeWidth: template.width * 0.006,
                textAlign: 'center',
                originX: 'center',
                originY: 'bottom',
                hasControls: true,
                cornerSize: 16,
                hoverCursor: 'move',
                moveCursor: 'move'
            });

            canvas.add(overlayTextObj);
            canvas.bringToFront(overlayTextObj);
            canvas.bringToFront(watermark);
            canvas.renderAll();
        }

        function updateOverlayText(text) {
            state.overlayText = text;
            if (state.showOverlay && text) {
                addOverlayText();
            } else if (overlayTextObj && !text) {
                canvas.remove(overlayTextObj);
                overlayTextObj = null;
                canvas.renderAll();
            }
        }

        function updateWatermarkOpacity(value) {
            state.watermarkOpacity = value;
            watermarkOpacityValue.textContent = value + '%';
            
            if (watermark) {
                watermark.set('opacity', value / 100);
                canvas.renderAll();
            }
        }

        // ============================================
        // GOOGLE DRIVE PICKER
        // ============================================
        // Google API Config - Replace with your credentials
        const GOOGLE_API_KEY = localStorage.getItem('samourais_google_api_key') || '';
        const GOOGLE_CLIENT_ID = localStorage.getItem('samourais_google_client_id') || '';
        const GOOGLE_APP_ID = '';
        let pickerApiLoaded = false;
        let oauthToken = null;

        function openGoogleDrivePicker() {
            if (!GOOGLE_API_KEY || !GOOGLE_CLIENT_ID) {
                showDriveConfigModal();
                return;
            }
            
            // Show loading
            driveConnect.style.display = 'none';
            driveLoading.style.display = 'flex';
            
            // Load the Google API
            gapi.load('auth2', () => {
                gapi.load('picker', () => {
                    pickerApiLoaded = true;
                    authenticateAndShowPicker();
                });
            });
        }

        function authenticateAndShowPicker() {
            gapi.auth2.authorize({
                client_id: GOOGLE_CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/drive.readonly',
                immediate: false
            }, (authResult) => {
                if (authResult && !authResult.error) {
                    oauthToken = authResult.access_token;
                    createPicker();
                } else {
                    driveLoading.style.display = 'none';
                    driveConnect.style.display = 'block';
                    console.error('Auth error:', authResult?.error);
                    alert('Erreur de connexion √† Google Drive. V√©rifie tes identifiants.');
                }
            });
        }

        function createPicker() {
            if (pickerApiLoaded && oauthToken) {
                const view = new google.picker.DocsView()
                    .setIncludeFolders(true)
                    .setMimeTypes('image/png,image/jpeg,image/gif,image/webp,video/mp4,video/quicktime,video/webm')
                    .setSelectFolderEnabled(false);
                
                const picker = new google.picker.PickerBuilder()
                    .setAppId(GOOGLE_APP_ID)
                    .setOAuthToken(oauthToken)
                    .addView(view)
                    .addView(new google.picker.DocsView().setIncludeFolders(true).setSelectFolderEnabled(true))
                    .setDeveloperKey(GOOGLE_API_KEY)
                    .setCallback(pickerCallback)
                    .setTitle('S√©lectionne une image ou vid√©o')
                    .setLocale('fr')
                    .build();
                
                picker.setVisible(true);
                
                // Hide loading
                driveLoading.style.display = 'none';
                driveConnect.style.display = 'block';
            }
        }

        function pickerCallback(data) {
            if (data.action === google.picker.Action.PICKED) {
                const file = data.docs[0];
                loadFromDrive(file);
            }
        }

        async function loadFromDrive(file) {
            driveConnect.style.display = 'none';
            driveLoading.style.display = 'flex';
            driveLoading.querySelector('span').textContent = 'Chargement de ' + file.name + '...';
            
            try {
                // Fetch the file content
                const response = await fetch(`https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`, {
                    headers: {
                        'Authorization': 'Bearer ' + oauthToken
                    }
                });
                
                const blob = await response.blob();
                const blobFile = new File([blob], file.name, { type: file.mimeType });
                
                // Switch back to local tab to show preview
                importTabs.forEach(t => t.classList.remove('active'));
                document.querySelector('.import-tab[data-source="local"]').classList.add('active');
                uploadZone.style.display = 'block';
                driveZone.style.display = 'none';
                
                // Load the file
                loadMedia(blobFile);
                
            } catch (error) {
                console.error('Error loading from Drive:', error);
                alert('Erreur lors du chargement du fichier depuis Drive');
                driveLoading.style.display = 'none';
                driveConnect.style.display = 'block';
            }
        }

        function showDriveConfigModal() {
            const modal = document.createElement('div');
            modal.id = 'drive-config-modal';
            modal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: #1a1a1a; border-radius: 16px; padding: 24px; max-width: 450px; width: 90%;">
                        <h3 style="margin-bottom: 16px; font-size: 18px;">‚öôÔ∏è Configuration Google Drive</h3>
                        <p style="color: #888; font-size: 13px; margin-bottom: 16px;">
                            Pour utiliser Google Drive, tu dois d'abord configurer tes identifiants Google Cloud.
                            <a href="https://console.cloud.google.com/" target="_blank" style="color: #ef4444;">Cr√©er un projet</a>
                        </p>
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; font-size: 12px; color: #888; margin-bottom: 6px;">API Key</label>
                            <input type="text" id="drive-api-key" placeholder="AIza..." 
                                   style="width: 100%; padding: 12px; background: #111; border: 2px solid #333; border-radius: 8px; color: #fff; font-size: 14px;">
                        </div>
                        <div style="margin-bottom: 16px;">
                            <label style="display: block; font-size: 12px; color: #888; margin-bottom: 6px;">Client ID</label>
                            <input type="text" id="drive-client-id" placeholder="xxxxx.apps.googleusercontent.com" 
                                   style="width: 100%; padding: 12px; background: #111; border: 2px solid #333; border-radius: 8px; color: #fff; font-size: 14px;">
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button onclick="document.getElementById('drive-config-modal').remove()" 
                                    style="flex: 1; padding: 12px; background: #333; border: none; border-radius: 8px; color: #fff; cursor: pointer;">
                                Annuler
                            </button>
                            <button onclick="saveDriveConfig()" 
                                    style="flex: 1; padding: 12px; background: #1a73e8; border: none; border-radius: 8px; color: #fff; cursor: pointer; font-weight: 600;">
                                Sauvegarder
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        window.saveDriveConfig = function() {
            const apiKey = document.getElementById('drive-api-key').value.trim();
            const clientId = document.getElementById('drive-client-id').value.trim();
            
            if (apiKey && clientId) {
                localStorage.setItem('samourais_google_api_key', apiKey);
                localStorage.setItem('samourais_google_client_id', clientId);
                document.getElementById('drive-config-modal').remove();
                
                // Reload to apply
                location.reload();
            } else {
                alert('Remplis les deux champs');
            }
        };

        // ============================================
        // RESET & EXPORT
        // ============================================
        function resetAll() {
            state.imageOffsetX = 0;
            state.imageOffsetY = 0;
            state.imageScale = 100;
            
            imageScaleSlider.value = 100;
            imageScaleValue.textContent = '100%';
            
            createElements();
            
            if (state.imageSrc) {
                addImageToCanvas(state.imageSrc);
            }
            if (state.showOverlay && state.overlayText) {
                addOverlayText();
            }
            updateText(state.text);
            updateTextSize(state.textSize);
        }

        function exportMeme() {
            if (state.mediaType === 'video') {
                exportVideo();
            } else {
                exportImage();
            }
        }

        function schedulePost() {
            // Capture current canvas state as image
            frameBorder.set({ visible: false });
            frameRect.set({ visible: false });
            canvas.discardActiveObject();
            canvas.renderAll();

            const template = TEMPLATES[state.currentTemplate];
            
            // Reset zoom temporarily for clean capture
            const originalZoom = canvas.getZoom();
            canvas.setZoom(1);
            canvas.setWidth(template.width + (CANVAS_PADDING * 2));
            canvas.setHeight(template.height + (CANVAS_PADDING * 2));
            canvas.renderAll();
            
            // Capture the canvas
            const dataURL = canvas.toDataURL({
                format: 'jpeg',
                quality: 0.9,
                left: CANVAS_PADDING,
                top: CANVAS_PADDING,
                width: template.width,
                height: template.height
            });

            // Restore zoom and size
            canvas.setZoom(originalZoom);
            updateCanvasSize();
            frameBorder.set({ visible: true });
            frameRect.set({ visible: true });
            canvas.renderAll();

            // Store in sessionStorage for calendar
            const postData = {
                mediaSrc: dataURL,
                mediaType: state.mediaType === 'video' ? 'video' : 'image',
                template: state.currentTemplate,
                caption: state.text || '',
                timestamp: Date.now()
            };
            
            sessionStorage.setItem('samourais_pending_post', JSON.stringify(postData));
            
            // Redirect to calendar
            window.location.href = 'calendar.html';
        }

        function exportImage() {
            // Hide elements we don't want in export
            frameBorder.set({ visible: false });
            frameRect.set({ visible: false });
            
            // Deselect all
            canvas.discardActiveObject();
            canvas.renderAll();

            const template = TEMPLATES[state.currentTemplate];
            
            // Reset zoom temporarily for clean export
            const originalZoom = canvas.getZoom();
            canvas.setZoom(1);
            canvas.setWidth(template.width + (CANVAS_PADDING * 2));
            canvas.setHeight(template.height + (CANVAS_PADDING * 2));
            canvas.renderAll();
            
            // Export only the template area (cropping out the padding)
            const dataURL = canvas.toDataURL({
                format: 'png',
                quality: 1,
                left: CANVAS_PADDING,
                top: CANVAS_PADDING,
                width: template.width,
                height: template.height
            });

            // Restore zoom and size
            canvas.setZoom(originalZoom);
            updateCanvasSize();
            
            // Restore frame border
            frameBorder.set({ visible: true });
            frameRect.set({ visible: true });
            canvas.renderAll();

            // Download
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 10);
            link.download = `samourais_meme_${state.currentTemplate}_${timestamp}.png`;
            link.href = dataURL;
            link.click();
        }

        async function exportVideo() {
            // Collect all parameters needed for video processing
            const template = TEMPLATES[state.currentTemplate];
            
            const exportParams = {
                // Template info
                template: state.currentTemplate,
                templateWidth: template.width,
                templateHeight: template.height,
                // Frame info
                frameX: template.frame.x,
                frameY: template.frame.y,
                frameWidth: template.frame.width,
                frameHeight: template.frame.height,
                frameRadius: template.frame.radius,
                // Video trim
                trimStart: state.trimStart,
                trimEnd: state.trimEnd,
                // Media position/scale
                imageScale: state.imageScale,
                imageOffsetX: state.imageOffsetX,
                imageOffsetY: state.imageOffsetY,
                // Text
                text: state.text,
                textSize: state.textSize,
                textX: textBox ? textBox.left - CANVAS_PADDING : template.textArea.x,
                textY: textBox ? textBox.top - CANVAS_PADDING : template.textArea.y,
                // Overlay
                overlayText: state.showOverlay ? state.overlayText : '',
                // Watermark position and opacity
                watermarkX: watermark ? watermark.left - CANVAS_PADDING : template.watermark.x,
                watermarkY: watermark ? watermark.top - CANVAS_PADDING : template.watermark.y,
                watermarkOpacity: state.watermarkOpacity,
            };

            console.log('Video export params:', exportParams);
            
            // Show processing modal
            showVideoExportModal(exportParams);
        }

        function showVideoExportModal(params) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.id = 'export-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
            
            const backendConfigured = !!BACKEND_URL;
            
            modal.innerHTML = `
                <div style="background: #1a1a1a; border-radius: 12px; padding: 32px; max-width: 500px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">üé¨</div>
                    <h2 style="margin-bottom: 16px; color: #fff;">Export Vid√©o</h2>
                    <p style="color: #888; margin-bottom: 24px; line-height: 1.6;">
                        ${backendConfigured 
                            ? `Backend configur√© ‚úÖ<br><span style="font-size: 11px; color: #666;">${BACKEND_URL}</span>`
                            : `L'export vid√©o n√©cessite un backend FFmpeg.`
                        }<br>
                        <strong style="color: #ef4444;">Dur√©e: ${formatTime(params.trimEnd - params.trimStart)}</strong>
                    </p>
                    <div style="background: #111; border-radius: 8px; padding: 16px; margin-bottom: 24px; text-align: left;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 8px;">PARAM√àTRES D'EXPORT</div>
                        <div style="font-size: 13px; color: #aaa; font-family: monospace;">
                            Template: ${params.template} (${params.templateWidth}x${params.templateHeight})<br>
                            Trim: ${formatTime(params.trimStart)} ‚Üí ${formatTime(params.trimEnd)}<br>
                            Scale: ${params.imageScale}%
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="document.getElementById('export-modal').remove()" 
                                style="flex: 1; padding: 12px; background: #333; border: none; border-radius: 8px; color: #fff; cursor: pointer;">
                            Annuler
                        </button>
                        <button onclick="startVideoProcessing()" 
                                style="flex: 1; padding: 12px; background: #ef4444; border: none; border-radius: 8px; color: #fff; cursor: pointer; font-weight: 600;">
                            üöÄ ${backendConfigured ? 'Exporter' : 'Configurer'}
                        </button>
                    </div>
                    ${backendConfigured ? `
                        <button onclick="resetBackendUrl()" 
                                style="margin-top: 12px; padding: 8px; background: none; border: none; color: #666; cursor: pointer; font-size: 11px; text-decoration: underline;">
                            Changer l'URL du backend
                        </button>
                    ` : ''}
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Store params globally for the export button
            window._videoExportParams = params;
        }

        window.resetBackendUrl = function() {
            localStorage.removeItem('samourais_backend_url');
            location.reload();
        };

        // ============================================
        // BACKEND CONFIG
        // ============================================
        // Change this to your Railway URL after deployment
        const BACKEND_URL = localStorage.getItem('samourais_backend_url') || '';

        // ============================================
        // LOGO WATERMARK CONFIG
        // ============================================
        const LOGO_URL = 'https://raw.githubusercontent.com/hologramblues/Amourais-app/main/samourais_logo_transparent_smooth.png';
        let logoImage = null;
        
        // Preload logo
        function loadLogo() {
            fabric.Image.fromURL(LOGO_URL, (img) => {
                if (img) {
                    logoImage = img;
                    console.log('Logo loaded successfully');
                    // Refresh watermark if canvas already initialized
                    if (canvas && watermark) {
                        const template = TEMPLATES[state.currentTemplate];
                        const wm = template.watermark;
                        const offset = CANVAS_PADDING;
                        
                        // Remove old text watermark
                        canvas.remove(watermark);
                        
                        // Add logo watermark
                        watermark = new fabric.Image(logoImage.getElement(), {
                            left: wm.x + offset,
                            top: wm.y + offset,
                            originX: 'right',
                            originY: 'bottom',
                            scaleX: 0.15,
                            scaleY: 0.15,
                            opacity: state.watermarkOpacity / 100,
                            selectable: true,
                            hasControls: true,
                            cornerSize: 16,
                            hoverCursor: 'move',
                            moveCursor: 'move'
                        });
                        canvas.add(watermark);
                        canvas.renderAll();
                    }
                }
            }, { crossOrigin: 'anonymous' });
        }

        // G√©n√©rer le template PNG avec trou transparent pour la vid√©o
        async function generateTemplatePNG() {
            const template = TEMPLATES[state.currentTemplate];
            const offset = CANVAS_PADDING;
            
            // Cr√©er un canvas temporaire √† la taille du template (sans padding)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = template.width;
            tempCanvas.height = template.height;
            const ctx = tempCanvas.getContext('2d');
            
            // Fond blanc
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, template.width, template.height);
            
            // D√©couper le trou pour la vid√©o (zone transparente avec coins arrondis)
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            
            const frame = template.frame;
            const radius = frame.radius || 0;
            
            // Dessiner un rectangle arrondi transparent
            ctx.beginPath();
            ctx.moveTo(frame.x + radius, frame.y);
            ctx.lineTo(frame.x + frame.width - radius, frame.y);
            ctx.quadraticCurveTo(frame.x + frame.width, frame.y, frame.x + frame.width, frame.y + radius);
            ctx.lineTo(frame.x + frame.width, frame.y + frame.height - radius);
            ctx.quadraticCurveTo(frame.x + frame.width, frame.y + frame.height, frame.x + frame.width - radius, frame.y + frame.height);
            ctx.lineTo(frame.x + radius, frame.y + frame.height);
            ctx.quadraticCurveTo(frame.x, frame.y + frame.height, frame.x, frame.y + frame.height - radius);
            ctx.lineTo(frame.x, frame.y + radius);
            ctx.quadraticCurveTo(frame.x, frame.y, frame.x + radius, frame.y);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Dessiner le texte principal (meme text)
            if (textBox && state.text) {
                ctx.save();
                ctx.font = `bold ${state.textSize}px "Bricolage Grotesque", Helvetica, Arial, sans-serif`;
                ctx.fillStyle = 'black';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                
                // Position du texte (convertir depuis Fabric.js)
                const textX = textBox.left - offset;
                const textY = textBox.top - offset;
                
                ctx.fillText(state.text, textX, textY);
                ctx.restore();
            }
            
            // Dessiner l'overlay text (si activ√©) - dans la zone du trou, donc avant le mask
            // Non, l'overlay doit √™tre SUR la vid√©o, donc on ne le met pas ici
            
            // Dessiner le logo watermark
            if (watermark && logoImage) {
                ctx.save();
                
                // Position du watermark (depuis Fabric.js - originX: right, originY: bottom)
                const wmLeft = watermark.left - offset;
                const wmTop = watermark.top - offset;
                const wmWidth = watermark.width * watermark.scaleX;
                const wmHeight = watermark.height * watermark.scaleY;
                
                // Opacit√©
                ctx.globalAlpha = state.watermarkOpacity / 100;
                
                // Le watermark est align√© right/bottom dans Fabric, donc:
                // left/top repr√©sentent le coin bottom-right
                ctx.drawImage(
                    logoImage.getElement(),
                    wmLeft - wmWidth,
                    wmTop - wmHeight,
                    wmWidth,
                    wmHeight
                );
                
                ctx.restore();
            }
            
            // Convertir en blob PNG
            return new Promise((resolve) => {
                tempCanvas.toBlob((blob) => {
                    resolve(blob);
                }, 'image/png');
            });
        }

        window.startVideoProcessing = async function() {
            const modal = document.getElementById('export-modal');
            const params = window._videoExportParams;
            
            // Validate backend URL
            let backendUrl = BACKEND_URL;
            if (!backendUrl) {
                modal.querySelector('div > div').innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 16px;">‚öôÔ∏è</div>
                    <h2 style="margin-bottom: 16px; color: #fff;">Configuration requise</h2>
                    <p style="color: #888; margin-bottom: 16px;">
                        Entre l'URL de ton backend Railway :
                    </p>
                    <input type="text" id="backend-url-input" placeholder="https://ton-app.railway.app" 
                           style="width: 100%; padding: 12px; background: #111; border: 2px solid #333; border-radius: 8px; color: #fff; font-size: 14px; margin-bottom: 16px;">
                    <div style="display: flex; gap: 12px;">
                        <button onclick="document.getElementById('export-modal').remove()" 
                                style="flex: 1; padding: 12px; background: #333; border: none; border-radius: 8px; color: #fff; cursor: pointer;">
                            Annuler
                        </button>
                        <button onclick="saveBackendUrl()" 
                                style="flex: 1; padding: 12px; background: #ef4444; border: none; border-radius: 8px; color: #fff; cursor: pointer; font-weight: 600;">
                            Sauvegarder
                        </button>
                    </div>
                `;
                return;
            }
            
            // Clean URL - remove trailing slash and add https if missing
            backendUrl = backendUrl.trim().replace(/\/+$/, '');
            if (!backendUrl.startsWith('http://') && !backendUrl.startsWith('https://')) {
                backendUrl = 'https://' + backendUrl;
            }
            
            // Show processing state
            modal.querySelector('div > div').innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px; animation: spin 1s linear infinite;">‚è≥</div>
                <style>@keyframes spin { to { transform: rotate(360deg); } }</style>
                <h2 style="margin-bottom: 16px; color: #fff;">Processing...</h2>
                <p style="color: #888; margin-bottom: 24px;">
                    G√©n√©ration du template et upload en cours...<br>
                    Cela peut prendre quelques secondes.
                </p>
                <div id="progress-bar" style="background: #333; border-radius: 4px; height: 8px; overflow: hidden; margin-bottom: 16px;">
                    <div id="progress-fill" style="background: #ef4444; height: 100%; width: 0%; transition: width 0.3s;"></div>
                </div>
                <p id="progress-text" style="color: #666; font-size: 12px;">Pr√©paration...</p>
            `;
            
            try {
                updateProgress(5, 'G√©n√©ration du template PNG...');
                
                // G√©n√©rer le template PNG avec trou transparent
                const templateBlob = await generateTemplatePNG();
                
                updateProgress(15, 'Pr√©paration de l\'upload...');
                
                // Create form data with video file, template PNG, and params
                const formData = new FormData();
                formData.append('video', state.videoFile);
                formData.append('template', templateBlob, 'template.png');
                formData.append('params', JSON.stringify({
                    templateWidth: params.templateWidth,
                    templateHeight: params.templateHeight,
                    frameX: params.frameX,
                    frameY: params.frameY,
                    frameWidth: params.frameWidth,
                    frameHeight: params.frameHeight,
                    trimStart: params.trimStart,
                    trimEnd: params.trimEnd,
                    imageScale: params.imageScale,
                    imageOffsetX: params.imageOffsetX,
                    imageOffsetY: params.imageOffsetY
                }));
                
                updateProgress(20, 'Upload de la vid√©o et du template...');
                
                const response = await fetch(`${backendUrl}/api/process-video`, {
                    method: 'POST',
                    body: formData
                });
                
                updateProgress(60, 'Traitement FFmpeg...');
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Erreur serveur');
                }
                
                updateProgress(90, 'T√©l√©chargement...');
                
                // Download the processed video
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `samourais_meme_${state.currentTemplate}_${Date.now()}.mp4`;
                link.click();
                URL.revokeObjectURL(url);
                
                updateProgress(100, 'Termin√© !');
                
                // Success state
                setTimeout(() => {
                    modal.querySelector('div > div').innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 16px;">‚úÖ</div>
                        <h2 style="margin-bottom: 16px; color: #fff;">Export r√©ussi !</h2>
                        <p style="color: #888; margin-bottom: 24px;">
                            Ta vid√©o a √©t√© t√©l√©charg√©e.
                        </p>
                        <button onclick="document.getElementById('export-modal').remove()" 
                                style="padding: 12px 32px; background: #ef4444; border: none; border-radius: 8px; color: #fff; cursor: pointer; font-weight: 600;">
                            Fermer
                        </button>
                    `;
                }, 500);
                
            } catch (error) {
                console.error('Export error:', error);
                modal.querySelector('div > div').innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                    <h2 style="margin-bottom: 16px; color: #fff;">Erreur</h2>
                    <p style="color: #ef4444; margin-bottom: 24px;">
                        ${error.message}
                    </p>
                    <div style="display: flex; gap: 12px;">
                        <button onclick="document.getElementById('export-modal').remove()" 
                                style="flex: 1; padding: 12px; background: #333; border: none; border-radius: 8px; color: #fff; cursor: pointer;">
                            Fermer
                        </button>
                        <button onclick="startVideoProcessing()" 
                                style="flex: 1; padding: 12px; background: #ef4444; border: none; border-radius: 8px; color: #fff; cursor: pointer; font-weight: 600;">
                            R√©essayer
                        </button>
                    </div>
                `;
            }
        };

        function updateProgress(percent, text) {
            const fill = document.getElementById('progress-fill');
            const textEl = document.getElementById('progress-text');
            if (fill) fill.style.width = percent + '%';
            if (textEl) textEl.textContent = text;
        }

        function showError(message) {
            const modal = document.getElementById('export-modal');
            if (modal) {
                modal.querySelector('div > div').innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 16px;">‚ùå</div>
                    <h2 style="margin-bottom: 16px; color: #fff;">Erreur</h2>
                    <p style="color: #ef4444; margin-bottom: 24px;">
                        ${message}
                    </p>
                    <button onclick="document.getElementById('export-modal').remove()" 
                            style="padding: 12px 32px; background: #333; border: none; border-radius: 8px; color: #fff; cursor: pointer;">
                        Fermer
                    </button>
                `;
            } else {
                alert(message);
            }
        }

        window.saveBackendUrl = function() {
            const input = document.getElementById('backend-url-input');
            let url = input.value.trim().replace(/\/+$/, ''); // Remove trailing slash
            
            // Add https if missing
            if (url && !url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            
            if (url) {
                localStorage.setItem('samourais_backend_url', url);
                location.reload(); // Reload to apply
            }
        };

        // ============================================
        // EVENT LISTENERS
        // ============================================
        function setupEventListeners() {
            // Format selection
            formatBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    formatBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.currentTemplate = btn.dataset.format;
                    state.imageOffsetX = 0;
                    state.imageOffsetY = 0;
                    state.imageScale = 100;
                    
                    imageScaleSlider.value = 100;
                    imageScaleValue.textContent = '100%';
                    
                    updateCanvasSize();
                    createElements();
                    
                    if (state.imageSrc) {
                        addImageToCanvas(state.imageSrc);
                    }
                    if (state.showOverlay && state.overlayText) {
                        addOverlayText();
                    }
                    updateText(state.text);
                });
            });

            // File upload - click
            uploadZone.addEventListener('click', () => fileInput.click());

            // File upload - drag & drop
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.style.borderColor = '#ef4444';
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.style.borderColor = '#333';
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.style.borderColor = '#333';
                const file = e.dataTransfer.files[0];
                if (file && (file.type.startsWith('image/') || file.type.startsWith('video/'))) {
                    loadMedia(file);
                }
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadMedia(file);
            });

            // Meme text
            memeTextInput.addEventListener('input', (e) => {
                updateText(e.target.value);
            });

            // Text size slider
            textSizeSlider.addEventListener('input', (e) => {
                updateTextSize(e.target.value);
            });

            // Image scale slider
            imageScaleSlider.addEventListener('input', (e) => {
                updateImageScale(parseInt(e.target.value));
            });

            // Select image button
            selectImageBtn.addEventListener('click', () => {
                if (imageObj) {
                    canvas.setActiveObject(imageObj);
                    canvas.renderAll();
                }
            });

            // Overlay toggle
            overlayToggle.addEventListener('click', toggleOverlay);

            // Overlay text
            overlayTextInput.addEventListener('input', (e) => {
                updateOverlayText(e.target.value);
            });

            // Reset
            resetBtn.addEventListener('click', resetAll);

            // Export
            exportBtn.addEventListener('click', exportMeme);

            // Schedule - send to calendar
            scheduleBtn.addEventListener('click', schedulePost);

            // Import source tabs
            importTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    importTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    const source = tab.dataset.source;
                    if (source === 'local') {
                        uploadZone.style.display = 'block';
                        driveZone.style.display = 'none';
                    } else if (source === 'drive') {
                        uploadZone.style.display = 'none';
                        driveZone.style.display = 'block';
                    }
                });
            });

            // Google Drive connect button
            connectDriveBtn.addEventListener('click', openGoogleDrivePicker);

            // Watermark opacity slider
            watermarkOpacitySlider.addEventListener('input', (e) => {
                updateWatermarkOpacity(parseInt(e.target.value));
            });

            // Window resize
            window.addEventListener('resize', () => {
                updateCanvasSize();
                canvas.renderAll();
            });
        }

        // ============================================
        // INIT
        // ============================================
        function init() {
            loadLogo(); // Preload logo for watermark
            initCanvas();
            setupEventListeners();
            setupTimelineInteraction();
        }

        init();
    </script>
</body>
</html>
